import{_ as d}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as s,a as l,d as e,e as o,b as t,f as n,r}from"./app.eb0a2683.js";const a={},u=n('<h1 id="网络安全" tabindex="-1"><a class="header-anchor" href="#网络安全" aria-hidden="true">#</a> 网络安全</h1><h2 id="什么是csrf" tabindex="-1"><a class="header-anchor" href="#什么是csrf" aria-hidden="true">#</a> 什么是CSRF</h2><p>CSRF(Cross-site request forgey)<code>跨站请求伪造</code>：攻击者诱导受害者进入第三方网站，在<code>第三方网站</code>中向被攻击者网站发送<code>跨站请求</code>。利用受害者在攻击网站已经获取的注册凭证，绕过后台用户验证，达到冒充用户对被攻击的网站执行某种操作的目的。</p><h3 id="一个典型的csrf攻击过程" tabindex="-1"><a class="header-anchor" href="#一个典型的csrf攻击过程" aria-hidden="true">#</a> 一个典型的CSRF攻击过程</h3><ul><li>受害者登录网站<code>a.com</code>，并保留了<code>登录凭证(Cookie)</code></li></ul>',5),h=e("ul",null,[e("li",null,[o("攻击者引诱受害者访问了"),e("code",null,"b.com")])],-1),S=e("ul",null,[e("li",null,[e("code",null,"b.com"),o("向"),e("code",null,"a.com"),o("发送了一个跨站请求:"),e("code",null,"a.com/act=xxx"),o(",浏览器会默认携带"),e("code",null,"a.com的Cookie")])],-1),p=e("ul",null,[e("li",null,[e("code",null,"a.com"),o("服务器接收到请求后，对请求进行验证，并确认受害者的凭证，误以为是受害者自己发送的请求")])],-1),_=e("ul",null,[e("li",null,[e("code",null,"a.com"),o("接收了以受害者名义发送的"),e("code",null,"act=xx")])],-1),m=e("ul",null,[e("li",null,"攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作 CSRF")],-1),T=e("h3",{id:"csrf的特点",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#csrf的特点","aria-hidden":"true"},"#"),o(" CSRF的"),e("code",null,"特点")],-1),f=e("ul",null,[e("li",null,[o("攻击发生在"),e("code",null,"第三方网站"),o("，被攻击网站无法阻止攻击发生")])],-1),k=e("ul",null,[e("li",null,[o("攻击利用受害者在被攻击网站的"),e("code",null,"登录凭证"),o("(整个过程"),e("code",null,"没有获取到受害者的登录凭证"),o("，，只是冒用)")])],-1),x=e("ul",null,[e("li",null,"跨站请求各种方式：图片URL、超链接、CORS、Form提交等等")],-1),g=e("h3",{id:"防护策略",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#防护策略","aria-hidden":"true"},"#"),o(" 防护策略")],-1),b=e("h4",{id:"阻止不明外域的访问",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#阻止不明外域的访问","aria-hidden":"true"},"#"),o(),e("strong",null,"阻止不明外域的访问")],-1),C=e("p",null,[e("em",null,[e("strong",null,[e("code",null,"同源检测")])]),o("，CSRF大多来自第三方网站，我们直接"),e("code",null,"禁止外域"),o("对我们发起请求 如何判断请求是否来自外域？ 在HTTP协议中，每一个异步请求都会携带两个Header,用于标记来源域名：")],-1),R=e("li",null,[e("p",null,[e("code",null,"Origin Header "),o("对应请求头"),e("code",null,"Origin"),o("字段，标识请求来源地址 。请求来源不包含path和query")]),e("ul",null,[e("li",null,"不存在Origin 字段的情况：1. IE11同源策略：不会在跨站CORS上添加Origin字段，Referer头是唯一标识 2. 302重定向，因为Origin重定向可能被认为是其他来源的敏感信息，因此浏览器不想Origin泄露到新服务器上")])],-1),L=e("code",null,"Referer Header",-1),P=e("code",null,"Referer",-1),H={href:"https://tech.meituan.com/2018/10/11/fe-security-csrf.html",target:"_blank",rel:"noopener noreferrer"},v=e("code",null,"same-origin",-1),O=e("li",null,[e("p",null,[e("em",null,[e("strong",null,[e("code",null,"SameSite Cookie")])]),o(" ： 有两个属性"),e("code",null,"Strict"),o("和"),e("code",null,"Lax")])],-1),M=n(`<p><code>Samesite=Strict</code>, 严格模式，表明这个Cookie在<code>任何情况下</code>都不可以作为第三方Cookie，绝无例外。 比如<code>b.com</code>设置了</p><pre><code>  \`\`\`
    Set-Cookie:foo=1;Samesite=Strict
    Set-Cookie:bar=2;Samesite=Lax
    Set-Cookie:baz=3
    \`\`\`
</code></pre><p>我们在<code>a.com</code>下发送对<code>b.com</code>的任意请求，<code>foo</code>这个cookie都不会被包含在<code>cookie</code>请求头中，但<code>bar</code>会 。</p><p><code>Samesite=Lax</code>, 宽松模式，比Strict放宽一点限制：加入这个请求(会改变了当前页面或打 开了新页面)，且同时是<code>GET请求</code>，则这个Cookie可以作为第三方请求。 同样:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Set-Cookie:foo=1;Samesite=Strict
Set-Cookie:bar=2;Samesite=Lax
Set-Cookie:baz=3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),N=n(`<p>如果<code>a.com</code>网站是<code>点击链接(GET请求)</code>，<code>foo</code>不会包含在Cookie请求头中，但是<code>bar</code>和<code>baz</code>会 如果<code>a.com</code>网站发起对<code>b.com</code>的异步请求，或者页面跳转是通过表单POST提交的，<code>bar</code>不会发送.</p><h4 id="提交时要求附加本域才能获取的信息" tabindex="-1"><a class="header-anchor" href="#提交时要求附加本域才能获取的信息" aria-hidden="true">#</a> <strong>提交时要求附加本域才能获取的信息</strong></h4><ul><li><p><em><strong><code>CSRF Token</code></strong></em>:CSRF产生的原因之一是服务器误把攻击者的请求当成了用户的请求，那我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求分开</p><ul><li><p>原理：三个步骤</p><ul><li><code>将CSRF Token输出到页面中</code>。服务器需要给这个用户生成一个Token,该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，Token就不能放Cookie中，最好存在服务器的Session中，之后每次页面加载时，用JS遍历整个DOM树，对所有的<code>a</code>和<code>form</code>标签加入Token(对于页面加载后动态生成的HTML代码)，需要我们手动加入</li><li><code>页面提交的请求携带这个Token</code>。GET请求可以拼接到URL后面，POST请求可以设置一个<code>&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;token&quot;&gt;</code>标签 3.<code>服务器验证Token是否正确</code>。服务器对Token进行解密，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，token有效。</li></ul></li></ul></li></ul><blockquote><p>分布式校验token 在大型网站中，使用session存储CSRF Token会带来很大的压力(session默认存储在单及服务器内存中)，在分布式环境下同一个用户发送的多次HTTP请求可能会先后落在不同的服务器上，导致后面发起的HTTP请求无法拿到之前HTTP请求存储在服务器中的Session数据，使得session机制在分布式环境下失效，<code>因此分布式集群中CSRF Token需要存储在Redis之类的公共存储空间</code> 使用Session存储，读取和验证CSRF Token会引起比较大的复杂度和性能问题，目前很多网站采用<code>Encryptyed Token Pattern</code>方式。这种方法的Token是一个计算出来的结果，而非随机生成的字符串.这样在校验时无需再去读取存储的Token,只用再计算一次即可。 Token值通常使用UserID、时间戳和随机数，通过加密的方法生成</p></blockquote><ul><li><em><strong><code>双重Cookie验证</code></strong></em> 就是在提交前先用js读取用于验证的cookie值加入到提交字段，这样验证字段有两份，<code>一份在cookie中，一份在POST或者URL中</code>。那CSRF只能让请求中带有Cookie但是不能读取cookie加入到POST或URL中</li></ul><p>优点：</p><pre><code>-   无需使用session,适用卖弄更广，易于实施
-   Tokens存储于客户端中，不会给服务器带来压力
-   相对于Token,实施成本低，可以在前后端设置统一拦截校验，无需一个个接口或一个个页面添加 缺点：
-   Cookie中添加了额外的字段
-   如果有XSS攻击，供给者可以注入Cookie
-   难以做到子域名的隔离
-   Cookie传输安全，采用这种防御方式最好确保用到整个HTTPS的方式
</code></pre><h2 id="xxs攻击" tabindex="-1"><a class="header-anchor" href="#xxs攻击" aria-hidden="true">#</a> XXS攻击</h2><p>Cross-Site Scripting(<code>跨站脚本攻击，简称XSS</code>)，是一种<code>恶意代码注入攻击</code>。供给者通过在目标网站注入恶意脚本，使之在用户浏览器上运行。利用这些恶意脚本，<code>供给者可获取用户的敏感信息</code>，如Cookie、SessionId等，进而危害数据安全。</p><p>XSS本质上就是 恶意代码未经过滤，与网站正常代码混在一起；浏览器无法辨别哪些脚本是可信的，导致恶意脚本运行，其来源：</p><ul><li>来自用户的<code>UGC</code>信息</li></ul>`,11),X=e("ul",null,[e("li",null,"来自第三方的链接")],-1),F=e("ul",null,[e("li",null,"URL参数")],-1),y=e("ul",null,[e("li",null,"POST参数")],-1),j=e("ul",null,[e("li",null,"Referer (可能来自不可信来源)")],-1),U=e("ul",null,[e("li",null,"Cookie(可能来自其他子域注入)")],-1),D=e("h3",{id:"xss的分类",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#xss的分类","aria-hidden":"true"},"#"),o(" XSS的分类")],-1),I=e("p",null,"三种：存储型、反射型和DON型",-1),q=e("p",null,[e("strong",null,"存储型XSS攻击步骤：")],-1),Y=e("ol",null,[e("li",null,[o("攻击者将恶意代码提交到目标网站的"),e("code",null,"数据库"),o("中")])],-1),E=e("ol",{start:"2"},[e("li",null,"用户打开目标网站时，网站服务端 将 恶意代码从数据库取出，拼接在HTML中返回给浏览器")],-1),A=e("ol",{start:"3"},[e("li",null,"用户浏览器接受到响应后解析执行，混在 其中 的恶意代码 也被执行")],-1),J=e("ol",{start:"4"},[e("li",null,"恶意代码窃取用户数据发送到 攻击者的网站 ，或者冒充用户行为，调用目标网站接口执行 攻击者执行操作 这种攻击常见于 带有用户保存数据的网站功能，如 论坛 、商品评论 、 用户私信等")],-1),V=e("p",null,[e("strong",null,"反射型XSS攻击步骤"),o("：")],-1),G=e("ol",null,[e("li",null,[o("攻击者构造出 "),e("code",null,"特殊的URL"),o("，其中包括恶意代码")])],-1),w=e("ol",{start:"2"},[e("li",null,"用户访问恶意代码URL时 ，网站服务将 恶意代码从URL中取出，拼接在HTML中返回浏览器")],-1),z=e("ol",{start:"3"},[e("li",null,"用户浏览器接收到响应后执行， 混在其中的恶意代码也被执行")],-1),B=e("ol",{start:"4"},[e("li",null,"恶意代码窃取用户数据发送到 攻击者的网站 ，或者冒充用户行为，调用目标网站接口执行 攻击者执行操作常见于通过URL传递参数的功能，如网站搜索、跳转等 与存储型XSS的区别：存储型XSS的恶意代码存在数据库里，反射型XSS的恶意代码存在URL里")],-1),W=e("p",null,[e("strong",null,"DOM型XSS的攻击步骤：")],-1),K=e("ol",null,[e("li",null,"攻击者构造出 特殊的URL , 其中包含恶意代码")],-1),Q=e("ol",{start:"2"},[e("li",null,"用户打开带有恶意代码的URL")],-1),Z=e("ol",{start:"3"},[e("li",null,"用户浏览器 接收到响应后解析执行 ， 前端js取出URL中的恶意代码并执行")],-1),$=n('<ol start="4"><li>恶意代码窃取用户数据发送到 攻击者的网站 ，或者冒充用户行为，调用目标网站接口执行 攻击者执行操作</li></ol><p>DOM型与前两种的区别：DOM型XSS攻击中，取出和执行恶意代码由浏览器完成，属于前端JS自身的安全漏洞，其他两种XSS都属于服务端的安全漏洞</p><h3 id="预防xss攻击" tabindex="-1"><a class="header-anchor" href="#预防xss攻击" aria-hidden="true">#</a> 预防XSS攻击</h3><ul><li><p><strong><code>预防存储型XSS和反射型XSS攻击</code></strong><code></code>存储型和反射型XSS都是<code>服务端</code>取出恶意代码后，插入到响应端HTML里，攻击者编写的 “ 数据” 被内嵌到“代码”中，被浏览器所执行。 预防：</p><ul><li><p><em><strong><code>改成纯前端渲染，把代码和数据分隔开来</code></strong></em><code></code>纯前端渲染的过程：</p><ul><li>浏览器加载一个HTML页面，该页面不包含任何数据</li><li>然后浏览器执行HTML中的js</li><li>js通过Ajax加载业务数据，调用DOM API更新到页面上 纯前端渲染可 识别哪些是文本<code>.innerText</code> 哪些是<code>.setAttribute</code>属性，哪些是<code>.style</code>样式等。但是需要避免DOM型XSS漏洞( <code>onLoad事件</code>和<code>href</code>中的<code>javascript:</code>等)</li></ul></li><li><p><strong>对</strong> <strong>HTML</strong> <strong>做充分的转义,可以使用合适的转义库ejs</strong></p></li></ul></li></ul>',4),ee=n(`<ul><li><p><strong>预防DOM型XSS攻击</strong></p><ul><li>使用<code>.innerHTML</code>、<code>outerHTML</code>、<code>document.write()</code>时需要小心，不要把不可信的数据作为HTML插入到页面，而应尽量使用<code>.textContent</code>、<code>setAttribute()</code></li><li>使用<code>Vue/React</code>技术栈，并且不使用<code>v-html</code>/<code>dangerouslySetInnerHTML</code>,就在前端render阶段避免使用<code>innerHTML</code>、<code>outerHTML</code>的XSS隐患</li><li>DOM中的内联事件监听器，如<code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code>等，<code>&lt;a&gt;</code>标签的<code>href</code>属性，js的<code>eval()</code>、<code>setTimeout()</code>、<code>setTimeout</code>等，都能把字符串作为代码运行。如果把不可信的数据拼接到字符串中传递给这些API，很容易产生安全隐患。</li></ul></li></ul><h2 id="jsonp可能产生的安全隐患" tabindex="-1"><a class="header-anchor" href="#jsonp可能产生的安全隐患" aria-hidden="true">#</a> JSONP可能产生的安全隐患</h2><h3 id="可能存在csrf攻击" tabindex="-1"><a class="header-anchor" href="#可能存在csrf攻击" aria-hidden="true">#</a> 可能存在CSRF攻击</h3><p>当某个网站通过JSONP的方式来传递用户敏感信息时，攻击者构造恶意的JSONP调用页面，诱导被攻击者访问来达到截取用户敏感信息的目的。</p><p>如下攻击代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;script&gt;
function Hack(){
    alert(v.username)
}
&lt;/script&gt;
&lt;script src=&quot;http://js.login.cn/?o=ss0&amp;m=info&amp;func=Hack&quot;&gt;&lt;/script&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当被攻击者在登陆<code>js</code>网站的情况下访问了该网页时，那么用户的隐私数据（如用户名，邮箱等）可能被攻击者劫持。</p><p>解决方案：Referer过滤</p><h3 id="可能存在xss攻击" tabindex="-1"><a class="header-anchor" href="#可能存在xss攻击" aria-hidden="true">#</a> 可能存在XSS攻击</h3><p>使用<code>Content-Type:application/javascript</code>造成HTML根据js解析文件，造成XSS</p><p>解决方案：严格使用<code>Content-Type: application/json</code></p>`,11),oe={href:"https://blog.knownsec.com/index.html%3Fp=2038.html#:~:text=JSONP",target:"_blank",rel:"noopener noreferrer"},le=n('<h2 id="https中间人攻击" tabindex="-1"><a class="header-anchor" href="#https中间人攻击" aria-hidden="true">#</a> HTTPS中间人攻击</h2><p><strong><code>中间人攻击</code></strong>：即(Main-in-the-middle attack|MITM) ，就是中<code>间人会在消息发出方和接收方之间拦截双方通讯，并进行信息篡改</code>。</p><p>常见的HTTPS中间人攻击，首先需要结合<code>ARP</code>(IP地址-&gt;Mac地址)、<code>DNS欺骗</code>技术进行拦截。</p><ol><li>SSL证书欺骗攻击</li></ol><p>通过<code>ARP欺骗、DNS劫持甚至网关劫持等</code>，将客户端的访问<code>重定向</code>到攻击者的机器，让客户端机器与攻击者机器建立HTTPS(使用伪造证书), 而攻击者再跟服务器建立连接。 虽然用户在浏览器看到的链接是相同域名的网站，<code>但浏览器会提示证书不可信</code>, 用户不点击继续浏览就能避免被劫持。</p><ol start="2"><li>SSL剥离攻击(SSLStrip)</li></ol><p>SSL剥离，即将<code>HTTPS连接降级到HTTP连接</code>。该方式主要是利用用户并不会每次都直接输入<code>https://xxx.xxx.com</code>来访问网站，或则有些网站并非全网HTTPS，而是只是在需要进行敏感数据传输时才使用HTTPS，中间人通过劫持了客户端与服务端的HTTP会话后，<code>将HTTP页面所有的https://超链接都换成http://``用户在点击链接时，使用HTTP协议进行访问。所以攻击者可以伪造响应数据发送给客户端。服务端在配置HTTPS服务时，加上</code>HTTP Strict Transport Security`配置项</p><ol start="3"><li>针对SSL算法进行攻击 OpenSSL漏洞</li></ol><p>防范措施：</p><ul><li><p>不要随意连入公共场所的WIFI，或者使用未知代理服务器</p></li><li><p>不要安装不可信或突然出现的描述文件，信任伪造的证书</p></li><li><p>客户端对服务器进行单独对比校验，确认证书不是伪造的。</p></li></ul><h2 id="syn攻击是什么" tabindex="-1"><a class="header-anchor" href="#syn攻击是什么" aria-hidden="true">#</a> SYN攻击是什么？</h2><p>是一种典型的DOS/DDOS攻击</p><p><code>服务端的资源分配是在第二次握手是分配的，而客户端的资源是在完成第三次报文握手时分配的</code>，所以服务器容易收到SYN攻击。SYN攻击就是**<code>Client在短时间内伪造大量不存在的IP地址</code>**，并向服务器不断的发送SYN包，并等客户端回应。但由于源地址不存在，服务器不断的重发超时，这些伪SYN包长时间的占用未连接队列，导致正常的SYN请求因为队列满而被抛弃，从而引起网络拥塞甚至系统瘫痪。</p><p><code>如何检验？</code>当你在服务器上看到大量半连接状态时+IP地址随机，基本上可以断定是SYN攻击。Linux/Uinx上可以使用<code>netstat -n -p TCP | grep SYN_RECV</code>进行检测</p><p><code>常见防御SYN攻击的方法：</code></p><ul><li>缩短超时(SYN Timeout)时间</li></ul>',16),ne=e("ul",null,[e("li",null,"增加最大半连接数")],-1),ce=e("ul",null,[e("li",null,"过滤网防护")],-1),te=e("p",null,"内容来源：",-1),de={href:"https://tech.meituan.com/2018/10/11/fe-security-csrf.html",target:"_blank",rel:"noopener noreferrer"},ie={href:"https://tech.meituan.com/2018/09/27/fe-security.html",target:"_blank",rel:"noopener noreferrer"},se={href:"https://blog.knownsec.com/index.html%3Fp=2038.html#:~:text=JSONP",target:"_blank",rel:"noopener noreferrer"};function re(ae,ue){const c=r("ExternalLinkIcon");return i(),s("div",null,[u,l(""),h,l(""),S,l(""),p,l(""),_,l(""),m,T,f,l(""),k,l(""),x,g,e("ul",null,[e("li",null,[b,e("ul",null,[e("li",null,[C,e("ul",null,[R,e("li",null,[e("p",null,[L,o(" 对应请求头"),P,o("字段 HTTP请求的来源地址。对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址；对于页面跳转，Referer为打开页面历史记录的前一个页面地址。Referer是由浏览器提供的，可能不安全，攻击者可以隐藏、甚至修改自己请求的Referer Referer Policy草案："),e("a",H,[o("https://tech.meituan.com/2018/10/11/fe-security-csrf.html"),t(c)]),o(" 设置Referer Policy: 比如设置成"),v,o(" ,对于同源的链接和引用，会发送Referer,referer 值为Host不带Path。如果是跨域访问，则不设置Referer 设置Referer")])])])]),O]),M])]),N,l(""),X,l(""),F,l(""),y,l(""),j,l(""),U,D,I,q,Y,l(""),E,l(""),A,l(""),J,V,G,l(""),w,l(""),z,l(""),B,W,K,l(""),Q,l(""),Z,l(""),$,l(""),ee,e("p",null,[e("a",oe,[o("详细内容见原文..."),t(c)])]),le,l(""),ne,l(""),ce,te,e("ol",null,[e("li",null,[e("a",de,[o("CSRF..."),t(c)])]),e("li",null,[e("a",ie,[o("XSS..."),t(c)])]),e("li",null,[e("a",se,[o("JSONP..."),t(c)])])])])}const pe=d(a,[["render",re],["__file","网络安全.html.vue"]]);export{pe as default};
