import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as l,c as i,f as o}from"./app.eb0a2683.js";const t={},a=o('<h2 id="http基础" tabindex="-1"><a class="header-anchor" href="#http基础" aria-hidden="true">#</a> HTTP基础</h2><h3 id="osi七层模型" tabindex="-1"><a class="header-anchor" href="#osi七层模型" aria-hidden="true">#</a> OSI七层模型</h3><ul><li>应用层：包含Https、Http、DNS、FTP、SMTP等协议，负责用户交互、应用操作等</li><li>表示层：把网络中的消息转换成应用层可以读取消息格式</li><li>会话层：完全概念层，负责建立会话，传输数据每次建立HTTP会话</li><li>传输层：保证了进程到进程之间的通信，协议TCP,UDP协议，包含流量控制、报文可达性</li><li>网络层：在同一个局域网中，确保可以将报文从另一个主机传输到另一个主机上</li><li>数据链路层：使用MAC地址连接到对应的交换机(路由器)</li><li>物理层：转发报文需要的一些介质</li></ul><h3 id="tcp-ip协议模型" tabindex="-1"><a class="header-anchor" href="#tcp-ip协议模型" aria-hidden="true">#</a> TCP/IP协议模型</h3><p>TCP/IP协议(传输控制协议)是指能够在多个不同网络间实现信息传输的协议簇，包含了TCP、IP、FTP、UDP、SMTP等协议构成的协议簇。</p><p>四层体系结构：</p><ul><li>应用层：应用程序沟通层，包含HTTP协议、文件传输FTP协议、简单电子邮件SMTP传输协议</li><li>传输层：提供应用程序之间的通信服务，主要功能是数据格式化、数据确认和丢失重传等。如传输控制协议TCP、用户数据报协议UDP等。</li><li>网络层：负责提供基本的数据封包传输功能，让每个数据包能够到达目的主机</li><li>数据链路层：接受IP数据包并进行传输，从网络上接收物理帧，抽取IP数据包转交给下一层，对实际的网络媒体管理。</li></ul><h3 id="五层网络协议体系结构" tabindex="-1"><a class="header-anchor" href="#五层网络协议体系结构" aria-hidden="true">#</a> 五层网络协议体系结构</h3><p>结合<code>OSI模型和TCP/IP</code>模型</p><ul><li>应用层：协议体系中的最高层，为用户应用程序提供通信服务。比如HTTP、FTP、DNS等</li><li>传输层：负责两个主机的<code>进程之间</code>的通信服务，因为一个主机有不同的进程，所以运输层有<code>分用和复用</code>功能。</li></ul><blockquote><p>分用：传输层将收到的消息分别交付给应用层相应的程序。 复用：多个应用程序可以同时使用下面运输层的服务。</p></blockquote><ul><li>网络层：将运输层的报文分组(IP数据报)，为同一局域网中的不同主机提供通信服务。</li><li>数据链路层：将网络层传输的数据报封装成帧，在相邻两个节点间的链路间, 透明的传输帧数据。</li><li>物理层：该层传输数据的单位是比特。</li></ul><h3 id="http的报文结构" tabindex="-1"><a class="header-anchor" href="#http的报文结构" aria-hidden="true">#</a> HTTP的报文结构</h3><blockquote><p>起始行 头部 空行 实体 起始行：<code>请求行 GET /home HTTP/1.1</code> 响应行(状态行)：<code>HTTP/1.1 200 OK</code></p></blockquote><ul><li>头部：主要是比较多的头部字段。 头部字段格式 <ul><li>字段名不区分大小写</li><li>字段名不允许出现空格，不可以出现下划线_</li><li>字段名后面必须紧跟<code>:</code></li></ul></li><li>空行：区分开头和实体</li><li>实体：具体数据body部分</li></ul><h3 id="content-type取值" tabindex="-1"><a class="header-anchor" href="#content-type取值" aria-hidden="true">#</a> Content-type取值</h3><p>Content-type用来向接收方指名实体的参数格式。可以出现在响应/请求报文头部</p><ol><li><p><code>application/x-www-form-urlencoded</code>： 将参数分解成 &amp; 拼接成的key-value形式，表单默认的提交参数格式</p></li><li><p><code>multipart/form-data</code>: 由form表单的<code>enctype</code>指明，它会将表达数据处理位为一条信息，以标签为单元，用分隔符(<code>-bounary-</code>)隔开</p></li><li><p><code>application/json</code> : 告诉服务器是序列化后的JSON字符串</p></li><li><p><code>binary(application/octet-stream)</code>： 一般用于提交二进制文件</p></li></ol><h3 id="头部字段" tabindex="-1"><a class="header-anchor" href="#头部字段" aria-hidden="true">#</a> 头部字段</h3><h4 id="通用头部" tabindex="-1"><a class="header-anchor" href="#通用头部" aria-hidden="true">#</a> 通用头部：</h4><p><code>Content-Length</code>: 范文请求种指明文件长度，(request和respond)</p><p>Request Header</p><ul><li>Referer: 本页面的上一个点击跳转页</li><li>Origin: 当前请求站名信息</li><li>User_Agent : 请求的浏览器版本信息等</li><li>Accept: 客户端支持接受的文本格式类型，与服务端返回的文本格式类型Content-Type对应</li><li>Accpet-encoding: 表示客户端支持的压缩算法</li><li>Accept-language: 表示客户端接受的语言</li></ul><p>Response Header</p><ul><li>Server: 表示服务器信息</li><li>Content-Type :服务端返回的内容类型</li><li>Content-encoding: 返回文件的压缩类型</li><li>Content-Language：返回语言类型</li></ul><h4 id="缓存相关字段" tabindex="-1"><a class="header-anchor" href="#缓存相关字段" aria-hidden="true">#</a> 缓存相关字段</h4><p>Request Header</p><ul><li>If-None-Match: 客户端提供的上一次请求返回的ETag信息</li><li>If-Since-Modified：客户端提供的上一次请求返回的Last-Modified信息</li></ul><p>Response Header</p><ul><li>Cache-Control：no-store,no-cache,public,表示是否使用浏览器缓存，max-age: 资源在本地的最大存活时间;</li><li>Expires：格林尼治时间，表示资源过期的时间点，本地时间可以修改以至资源过期</li><li>ETag : 表示服务端资源标识，可以精确到ms</li><li>Last-Modified: 表示服务端最后一次修改时间，可以精确到s</li></ul><h4 id="范围请求-大文件信息" tabindex="-1"><a class="header-anchor" href="#范围请求-大文件信息" aria-hidden="true">#</a> 范围请求- 大文件信息</h4><p>Request Header</p><ul><li>Accept-Range:bytes： 客户端接受的请求范围</li><li>Content-Length: 请求的完整大小</li><li>Range:bytes=10-20请求范围，单位字节</li></ul><p>Response Header</p><ul><li>Content-Range:bytes 0-50/1270 响应回来的内容长度</li><li>Content-Length:50 完整的响应大小</li></ul><h4 id="cookie相关的" tabindex="-1"><a class="header-anchor" href="#cookie相关的" aria-hidden="true">#</a> Cookie相关的</h4><p>Request Header</p><ul><li>Cookie: 多个key-value形式的键值对组成</li><li>Respond Header</li><li>Set_Cookie: 一个key-value键值对，一个响应投可以有多个Set-Cookie</li></ul><h4 id="cors实现跨域请求" tabindex="-1"><a class="header-anchor" href="#cors实现跨域请求" aria-hidden="true">#</a> CORS实现跨域请求</h4><p>Request Header</p><p>Respond Header</p><ul><li>Access-Control-Allow-Origin： 服务端支持CORS跨域请求的域名</li><li>Access-Control-Allow-Credentials:true: 服务端请求携带Cookie</li><li>Access-Control-Allow-Method: 服务端允许跨域请求的方法</li><li>Access-Control-Allow-Headers:Content-Type:允许跨域请求设置请求头</li></ul><h3 id="http-1-0" tabindex="-1"><a class="header-anchor" href="#http-1-0" aria-hidden="true">#</a> HTTP/1.0</h3><p>特点：</p><ol><li><code>短链接(无状态)</code>，即发送一次请求建立一条TCP连接，请求处理完之后立即断开连接，不复用请求上下文信息</li><li><code>队头阻塞</code>：发送消息是<code>一发一收</code>形式，也就是发送请求报文时必须等到上一个请求报文发送并得到服务端响应之后才能发送下一个报文，如果上一个报文迟迟没有得到响应，就会阻塞请求队列中的报文发送</li></ol><h3 id="http-1-1" tabindex="-1"><a class="header-anchor" href="#http-1-1" aria-hidden="true">#</a> HTTP/1.1</h3><ol><li><code>长连接</code>，增加了响应头部<code>connection:keep-alive</code>；表示一条TCP连接可以复用，发送多个HTTP请求。</li><li><code>管线化传输(流水线传输)</code>，也就是为了解决HTTP/1.0中对头阻塞问题，让发送端可以连续发送多条请求报文，试图解决阻塞问题。但是在服务端依旧需要顺序接受请求报文并返回响应，所以实际上阻塞问题只是从客户端转移到服务端，没有根本上解决对头阻塞问题。</li><li><code>增加host请求头字段</code>。该字段可以使得服务由一个物理主机开启的多台虚拟主机，通过host请求头找到对应虚拟主机，也就是HTTP/1.0中只能一个域名对应一条物理主机，但是HTTP/1.1中增加host字段，让一台物理主机通过子域名衍生多台虚拟主机，这样可以增加TCP连接数。</li><li><code>可以传输动态数据</code>。HTTP/1.0中只能传输固定数据长度。HTTP/1.1中增加了Chunk Transfer头部字段，解决不定长数据传输问题。</li></ol><blockquote><p>HTTP/1.1 通过增加TCP的方式解决队头阻塞问题：域名分片和并发连接</p></blockquote><h3 id="http-2-0" tabindex="-1"><a class="header-anchor" href="#http-2-0" aria-hidden="true">#</a> HTTP/2.0</h3><ol><li><code>二进制分帧</code></li></ol><p>http2引入二进制帧代替原来http1中应用层的文本传输格式，在客户端和服务端都引入了二进制编码和解码的机制。 二进制分帧是http2.0通信的最小传输单位，它组成包括帧首部、帧长度、帧类型、标志位、流标识符、优先值和帧净荷等。</p><p>流是连接中的一个虚拟信道，可以承载双向消息传输。每个流都有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务端发起的流具有偶数ID。</p><p>所有的http2.0通信都是在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流Stream。客户端/服务端的消息由一个或多个帧组成，这些帧可以乱序发送，然后在达到接收方时通过每个帧首部的流标识符重新组装。</p><p>2.<code>多路复用</code> 一条TCP连接可以同时并行多个数据流的传输，双方通信可以同时发送请求和相应。HTTP消息被分解成独立的帧，而不破坏本身语义，交错发送出去，然后在另一端根据流ID和首部将它们重新组合在一起。</p><p>3.<code>请求优先级</code>：双方都要支持优先级控制 流可以带有一个31bit的优先级：</p><ul><li>0表示最高优先级</li><li>2^31-1表示最低优先级</li></ul><p>4.<code>服务端推送</code> http2.0增加了服务端推送功能，服务端可以根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。 <code>PUSH_PROMISE</code>帧是服务端向客户端有意推送资源的信号。</p><ul><li>如果客户端不需要服务端push，可在STRINGS帧中设定服务端流的值为0，禁用此功能</li><li>PUSH_PROMISE帧中只包含了预推送资源的首部。如果客户端对PUSH_PROMISE帧没有意见，服务端在PUSH_PROMISE帧后发送响应的DATA帧开始推送资源。如果客户端已经缓存了该资源，不需要要再推送，可以选择拒绝PUSH_PROMISE帧</li><li>PUSH_PROMISE必须遵循请求-响应原则，只能借着对请求的响应推送资源。</li></ul><ol start="5"><li><code>头部压缩</code> http1.x中每次通信(请求/响应)都会携带首部信息用户描述资源属性。HTTP2.0在客户端和服务端之间使用&quot;首部表&quot;来跟踪和存储之前发送的键-值对，使用HPACK算法对头部压缩。</li></ol><blockquote><p>http2.0存在的问题，只是将应用层的传输格式变成了二进制分帧流的方式进行传输，但是在传输层，也就是TCP层依旧存在对头阻塞问题，依旧需要发送数据流。 http2.0的多路复用技术是在http层实现的，将http报文的内容改成了进制帧，也就是frame。一条tcp可以被多个http会话连接复用，双向数据流。流标识是描述二进制frame的格式，使得每个frame都能够基于http2发送。一个独立双向的frame存在于客户端和服务器之间的http2中。客户端发起的流具有奇数ID，服务端发起的流具有偶数ID。</p></blockquote><blockquote><p>HTTP1.1中如何解决对头阻塞问题？</p><ol><li>域名分片：像test.com的一级域名，可以下层分配多个二级子域名，它们可以指向同一台服务器，这样也增加了并发连接的数量。</li><li>并发连接：一个域名允许分配多个长连接，Chrome支持6条HTTP连接</li></ol></blockquote><blockquote><p>请求13张图片或者一个HTML文件中有13个js文件，每个文件加载时间为1秒。HTTP1.1和HTTP2.0的区别是什么?</p><ul><li>HTTP1.1+同域名下。浏览器对同一域名下可以并发6条TCP连接(chrome)。HTTP1.1在服务端只能顺序处理多个请求，总时间是6 + 6 +1 = 13s</li><li>HTTP1.1+不同域名下。浏览器可以对js进行下载，总时间是1s</li><li>HTTP2.0+相同域名下，HTTP2可以多路复用，一个TCP连接可以并发处理多个HTTP请求。总时间是1s</li><li>HTTP2.0+不同域名下：1s</li></ul></blockquote><blockquote><p>http2.0的缺点</p><ol><li>如果http2出现丢帧，TCP为了保证可靠传输，会开启超时重传机制，丢包必须等待重传确认，导致队头阻塞，有可能不如http1.1的多个TCP连接。</li><li>多路复用没有限制同时请求的数量，请求如果短暂爆发式增长，导致服务器资源有限，每个流的资源会被稀释，可能产生超时。</li></ol></blockquote><h3 id="http3" tabindex="-1"><a class="header-anchor" href="#http3" aria-hidden="true">#</a> HTTP3</h3><ul><li>使用基于<code>UDP协议</code>的QUICK协议进行传输</li></ul><blockquote><p>对UDP无连接的理解：对于发送方而言，一个UDP套接字可以向多个客户端发送消息；对于接收者而言，一个UDP套接字也可以接受多个服务器发来的消息。通信双方并没有保持一个固定的连接。</p></blockquote><ul><li>无需进行多次报文握手,<code>0RTT</code></li></ul><p>传统的HTTP/2.0(默认开启HTTPS传输数据)需要至少3个RTT才 能建立TCP连接(1RTT用于TCP三次报文握手，2次用于TLS非对称加密挥手)，而HTTP/3.0仅仅使用1RTT就可以传递数据，当使用缓存时，可以将RTT减为0 其实现的核心是<code>DH算法</code>：交换传输的密钥</p><ol><li>首先客户端发送Inchoate Client Hello 给服务端，请求连接</li><li>服务端生成g、p、a三个随机数算出A，然后将g、p、A(保留a、p、g)放到Server Config中再发送Rejection消息到客户端。</li><li>客户端收到g、p、A后，生成随机数b, 根据g、p、b算出B，然后根据A、p、b算出初始密钥K ，然后用K加密HTTP数据，连同B一起发送给服务端。</li><li>服务端收到B后，根据a、p、B生成与客户端一样的密钥，解密HTTP数据。服务端会更新自己的随机数，再生成新密钥S，然后把公钥通过Server Hello发送给客户端，返回Http数据</li><li>客户端收到Server Hello，生成与服务端一致的新密钥S，后面传输都使用密钥S . 缓存Server Config可以实现0RTT</li></ol><ul><li><code>连接迁移</code></li></ul><p>传统的连接都是通过四元组(源IP、源端口、目的IP、目的端口)标识连接，其中一个发送改变，需要再次建立TCP连接，增加时延。 HTTP/3.0中使用64位的随机数(Connection ID)标识连接，只要Connection ID没有发生变化，连接依旧可以维持。比如用户的IP地发生改变，但是仍然保留上下文信息(连接ID、TLS密钥等)，可以复用连接。连接迁移</p><ul><li><code>多路复用/队头阻塞</code></li></ul><p>HTTP/1.x中，TCP面向连接的协议，发送请求需要收到ACK，确认对方已经收到数据。如果每个请求都需要接收到ACK再发送新的请求效率就会降低，在HTTP/1.1中使用了pipelining的方式，允许一个TCP连接发送多个请求。</p><p>HTTP/2.0中使用二进制分帧(frame)，将请求粒度减小，但是TCP层Frame组合得到Stream进行传输，一旦出现Stream中的Frame丢失，其后面的Stream就会被阻塞。</p><p>HTTP/3.0中传输单元和加密单元都是Packet，不提供可靠传输，数据包在接收端没有顺序处理，即使中间丢失一个包，也不会影响其他资源的处理，所以不会造成阻塞。</p><ul><li><code>拥塞控制</code><ul><li>热拨插：TCP的拥塞控制在传输层，而QUIC可以在应用层，用户根据不同网络环境选择拥塞控制方法</li><li>前向纠错：将数据切割成包后对每个包进行异或运算，将运算结果随数据发送。但其中一个包丢失，可以根据另外其他包推算出</li><li>单调递增的Packet Number</li><li>ACK delay</li></ul></li><li><code>流量控制</code> TCP使用滑动窗口的方式对发送方的流量进行控制，而对接收方并无限制，在QUIC中补齐了这个短板。 QUIC中接收方从单条Stream和整条连接两个角度动态调整接受窗口大小。</li></ul><h3 id="状态码" tabindex="-1"><a class="header-anchor" href="#状态码" aria-hidden="true">#</a> 状态码</h3><ul><li>1xx : 请求处理中，请求需要进一步处理才能完成。 <ul><li>101:协议升级 ，需要客户端带Upgrade请求头升级协议</li></ul></li><li>2xx : 请求成功响应 <ul><li>200, OK成功</li><li>204：Not Content响应没有包体，客户端无需更新当前页面</li><li>205: Reset Content响应没有包体，客户端需更新当前页面</li><li>206：Partial Content，使用Range协议时，断点传输，获取大文件</li></ul></li><li>3xx: 重定向 <ul><li>301 ：永久重定向，在请求URL已被移除，响应的- location首部中应该包含资源现在所在的URL</li><li>302：临时重定向，请求的URL发生改变</li><li>303：See Other ，URL发生改变，重定向使用GET方法发送请求。</li><li>304：协商缓存，服务器资源未发生改变</li><li>307: 临时重定向，重定向前后请求方法不变</li><li>308: 永久重定向，重定向前后请求方法改变</li></ul></li><li>4xx: 客户端错误 <ul><li>400 : Bad Request 服务端任务客户端错误，但没有指名哪种错误，有可能是HTTP请求格式错误</li><li>401 : 未授权访问，客户端未提供用户账号信息</li><li>402: 支付访问</li><li>403：Forbidden 服务器理解请求，但无权限访问</li><li>404: Not Found资源未找到</li><li>408：Request Timeout 请求超时</li><li>413：请求包体超出服务器能处理的范围</li></ul></li></ul><blockquote><p>报400状态码,如果排查错误?</p><ol><li>前端提交数据的字段名类型或名称等于后台对应请求的字段名不一致</li><li>请求类型与后端处理不一致,比如后端接受的时JSON字符串形式,而前端必须使用JSON.stringify转换为字符串,同时将contentType只是为application/json</li><li>有可能是Get请求的url太长,超过服务器或者浏览器处理的范围</li></ol></blockquote><ul><li>5xx: 服务端错误 <ul><li><p>500：Internal Server Error服务器内部发生错误</p></li><li><p>501: Not Implemented 服务器不支持请求所需功能</p></li><li><p>502:Bad Gateway 代理服务器无法获取原服务器响应</p></li><li><p>503: Service Unavailable 并发或者其他原因导致服务器尚未准备好处理当前请求</p></li><li><p>504:Gateway Timeout代理服务超时获取原服务器</p></li></ul></li></ul><h3 id="uri的构成" tabindex="-1"><a class="header-anchor" href="#uri的构成" aria-hidden="true">#</a> URI的构成</h3><p>URI，全称是统一资源标识符，作用就是区分互联网上不同的资源；</p><blockquote><p>与URL：URL是指网址 ，实际上的URI包括了URN和URL两部分 <code>scheme</code> 😕/ user:passwd@ host:port path ?query #fragment</p></blockquote><p><code>scheme</code>:协议名 比如http,https,ftp</p><p><code>user:passwd@</code> 表示登录主机时的用户信息，不过不安全，不推荐使用</p><p><code>host:port</code>表示主机名和端口号(有时候端口号是默认，没有显示写出来)</p><p><code>path</code>:路径，标志资源所在位置</p><p><code>query</code>:查询参数 key=val 格式 多对键值&amp;隔开</p><p><code>fragment</code>：表示URI所定位的资源内的一个锚点，浏览器可以根据这个锚点跳到网页对应位置</p><blockquote><p>URI编码：URI只能使用ASCII，其他不支持显示，而且还有一部分的界定符，如果不加以处理会导致解析出错。所以URI引入编码机制，将所有非ASCII码字符和界定符转为十六进制字节值，然后前面加一个% ,比如空格转义成%20,三元(中文)被转义成%E4%B8%89%E5%85%83</p></blockquote><h3 id="有哪些请求方法" tabindex="-1"><a class="header-anchor" href="#有哪些请求方法" aria-hidden="true">#</a> 有哪些请求方法</h3><ul><li><code>GET</code>：获取资源 幂等</li><li><code>POST</code>，提交资源 非幂等</li><li><code>HEAD</code>：大文件传输时，使用HEAD请求获取资源的元数据</li><li><code>OPTIONS</code>：CORS复杂请求解决跨域问题，用到一次OPTIONS的预检请求 幂等</li><li><code>PUT</code>：更新资源，带条件时是幂等的</li><li><code>DELETE</code>：删除资源</li><li><code>CONNECT</code>：建立tenel通道</li><li><code>TRACE</code>: 回显服务器</li></ul><h4 id="get和post请求的区别" tabindex="-1"><a class="header-anchor" href="#get和post请求的区别" aria-hidden="true">#</a> GET和POST请求的区别</h4><ol><li>从参数角度，GET请求参数是通过&amp;分隔符连接，暴露在URL上。POST是在请求体中</li><li>从缓存角度，GET请求资源会被浏览器主动缓存，而POST不会</li><li>从编码角度，GET请求按照ASCII对URL进行编码解析，但是POST请求编码没有限定</li><li>幂等，GET请求是幂等的，而POST不是</li></ol><h4 id="post那么多优点-为什么不用post取代get" tabindex="-1"><a class="header-anchor" href="#post那么多优点-为什么不用post取代get" aria-hidden="true">#</a> POST那么多优点，为什么不用POST取代GET？</h4><ul><li>POST强调的是提交数据到服务器，GET强调的是从服务器获取数据。</li><li>浏览器会自动缓存GET获取到的数据。</li><li>GET请求可以手动输入，可以存在书签，历史记录里。</li><li>GET请求的URL可以被搜索引擎收录到。</li><li>POST请求需要先发送一次请求头，在发生请求体，而GET请求直接发送请求。</li></ul><p>PUT和POST请求的区别 PUT更新资源或提交资源,是幂等操作,而POST不是</p><h3 id="http半全双工、websocket全双工的理解" tabindex="-1"><a class="header-anchor" href="#http半全双工、websocket全双工的理解" aria-hidden="true">#</a> HTTP半全双工、WebSocket全双工的理解</h3><p>HTTP是单向的，无状态协议。客户端发送请求，服务端发送响应，每条请求都与每条响应相关联。每个HTTP或HTTPS请求每次都会和服务器 新建立连接，并且得到响应后，连接自行终止。</p><p>WebSocket是双向的，有状态协议，在客户端-服务端通信场景中使用的全双工协议。ws://或 为、wss://开头。它始终保持客户端和服务端的保持活动状态，直到被任何一方关闭终止。</p><blockquote><p>何时使用到WebSocket？即时web应用程序(需要服务端实时发送数据)、游戏应用程序(无需刷新、服务器持续接受数据)、聊天应用程序。 WebSocket是H5提供的一种浏览器和客户端进行全双工通信的网络技术，属于应用层协议。</p></blockquote><ul><li>支持双向通信，更实时、更高效、更灵活、可扩展性更强。</li><li>较小的上下文开销。数据交换时，协议控制的数据包头部较小，在不包含头部的情况下，服务端到客户端的包头只有2-10个字节(取决于数据包长度)，客户端到服务端还需要加上额外的4个字节掩码。而HTTP每次通信都需要携带完整的头部。</li></ul><p><strong>webScoket心跳机制</strong></p><ul><li>为了定时发送消息，使连接不超时自动断线，避免后端设置时间自动断线，需要定时发送消息给后端，让服务器知道连接还在通消息不能断</li><li>为了检测在正常连接的状态下，后端是正常的。</li></ul><h3 id="dns" tabindex="-1"><a class="header-anchor" href="#dns" aria-hidden="true">#</a> DNS</h3><p>dns-prefetch提前解析可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，提高网站访问速度。 为何？当同一时间内，有多个请求都发送给同一个服务器，那DNS会多次并且重复触发，然后浏览器才能发送请求。</p><p>dns-prefetch原理：当浏览器访问一个域名时，需要解析一个DNS，获得对应域名的ip地址。解析过程中会逐步访问：</p><ul><li>浏览器缓存</li><li>系统缓存</li><li>路由器缓存</li><li>本地域名服务器(ISP运营商的DNS缓存)</li><li>根域名服务器</li><li>顶级域名服务器</li><li>权限域名服务器 dns-prefecth会将解析后的IP缓存在系统中。</li></ul><p>DNS劫持是攻击者利用某种攻击手段，篡改某域名下的解析结果，使得该域名下的IP变成了另一个IP，导致对应的网址被重定向到了另一个不可达或假冒的网址，从而达到非法窃听用户信息或破坏正常网络服务的目的。</p><p><strong>几种DNS攻击情况</strong> 1.在中间人(MiTM)DNS劫持攻击中，攻击者执行中间人攻击以拦截用户和DNS服务器之间的通信并提供不同的目标IP地址，从而将用户重定向到恶意网站 2. 攻击者可以破解DNS服务器，并更改DNS记录以将DNS请求重定向到恶意站点 3. 在本地DNS劫持中，攻击者在用户系统上植入恶意软件并修改本地DNS，用户使用攻击者控制的DNS服务器，将网站域请求转换重定向到恶意站点IP地址 4. 路由器DNS</p><h3 id="tcp如何保证可靠传输" tabindex="-1"><a class="header-anchor" href="#tcp如何保证可靠传输" aria-hidden="true">#</a> TCP如何保证可靠传输</h3><ol><li><code>序列号</code>： TCP传输时将每个字节的数据都进行了编号，根据编号重组报文。</li><li><code>确认应答</code>：TCP传输过程中，每次接受方接受到数据，都会对传输方进行确认应答(发送ACK报文)，告诉发送方下次期望收到的序列号。</li><li><code>超时重传</code>：基于序列号和确认应答机制，当发送方发送部分数据后，都会等待接收方发送的ACK，解析ACK报文，判断数据是否传输成功。如果长时间未收到确认报文，就启动重传机制，发送方在报文发送出去之后开始计时，超过最大等待时间，就启动重传。</li><li><code>流量控制</code>：通过滑动窗口机制控制发送窗口大小，保证发送方发送的数据不要过快，让接受方可以及时接受。</li><li><code>拥塞控制</code>：慢启动、拥塞避免、快恢复、快重传等算法。 <ul><li>慢启动：发送方向接受方发送1个单位的数据，收到对方确认后会发送2单位数据，然后依次是4个、8个....，呈指数级增长，这个过程是在不断试探网络的拥塞程度，超出阈值则会导致网络拥塞；</li><li>拥塞避免：指数增长不可能是无限的，到达某个限制(慢启动的阈值)之后，指数增长变成线性增长。</li><li>快重传：发送方在收到接收方三个重复的确认报文，就应该立即重传对方尚未收到的报文段。</li><li>快恢复：发送方在收到接收方三个重复的确认报文，就执行乘法减少的算法，把慢开始门ssthresh减半。由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始算法不同的是：现在不执行慢开始算法，而是把cwnd（发送窗口值）设置为慢开始门限值ssthresh减半后的数值，然后开始执行拥塞避免算法(&quot;加法增大&quot;)，使得拥塞窗口减慢地线性增大。</li></ul></li></ol><h3 id="udp如何保证数据可靠的传输" tabindex="-1"><a class="header-anchor" href="#udp如何保证数据可靠的传输" aria-hidden="true">#</a> UDP如何保证数据可靠的传输</h3><p>UDP是无连接的，消耗资源少，处理速度快，可以使用在实时视频、音频的传送。传输层无法保证数据的可靠性传输，可能通过应用层来实现，将TCP保证可靠性传输的策略移动到了应用层。 比如超时控制、响应确认</p><p>过程：发送端在发送数据时，生成一个随机的seq = x(序列号)，然后每片按照数据大小分配seq。数据到达接受端放入缓存，并发送一个ack=xd的确认包，表示对方已经收到了数据。发送端收到ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。 比如开源程序：RUDP、RTP、UDT等</p><h3 id="tcp所有的定时器" tabindex="-1"><a class="header-anchor" href="#tcp所有的定时器" aria-hidden="true">#</a> TCP所有的定时器</h3><ol><li><code>重传定时器</code>：用来计算TCP报文段超时重传的时间。每发送一个报文段就会启动重传定时，假设在定时器时间到后还未收到对该报文段的确认，就重传该报文段，并将重传计时器复位，再次启动计算，等收到报文段的确认后，则撤销该报文段的重传定时器。 2.<code>持续定时器</code>：为了应对零窗体可能导致的死锁问题。假设接收端向发送端发送零端口报文端不久后，接受端由存储空间了，于是又给接收端发送一个非零窗体大小的报文段，但是这个报文段在传送过程丢失了，发送端并没有收到，一直处于等待状态，而接受端觉得自己发了，所以也会一直等待发送端发送数据，造成死锁。所以TCP为每条连接都设置了一个持续定时器，只要连接的任一方发送了零窗口通知，就启动持续定时器。若定时器到期，就发送一个零窗口的探测报文(这个报文段仅仅只有一个字节，它有一个序号，但该序号永远不需要确认，因此该序号能够持续重传)。</li><li><code>保活定时器</code>：为了应对两个TCP连接间出现了长时间的没有传输数据的情况。比如客户端和服务端建立TCP，但后来客户端主机故障了，server就不能再收到客户端发来的数据，为了防止它一直等待下去，server就会设置一个保活定时器，通常为2小时，假设2小时没有收到客户端的报文，服务端就发送一个探测报文，以后每隔x秒发送一次，如果多次没有收到客户端响应，就终止连接。</li><li><code>2MSL定时器</code>：2MSL定时器是为了确保发送的最后一个报文段能够到达对方，并防止之前与本连接有关但因为延迟等原因导致已失效的报文被判定为有效。</li></ol><h3 id="tcp三次报文握手" tabindex="-1"><a class="header-anchor" href="#tcp三次报文握手" aria-hidden="true">#</a> TCP三次报文握手</h3><p>客户端处理Closed状态，服务端处于Listen状态</p><ol><li>客户端向服务端发送SYN=1报文，包含初始序列号seq，进入SYN_SEND状态</li><li>服务端收到客户端的SYN报文，以自己的SYN报文作为应答，指定自己的初始序列号seq，把客户端初始序列号+1作为ACK确认号，向客户端响应SYN-ACK报文，进入SYN_RCVD状态。</li><li>客户端在收到服务端的响应报文，把服务端初始序列号+1作为确认号ACK，向服务端发送ACK报文，客户端进入ESTABLISHED状态，服务端在收到确认报文也进入ESTABLISHED。</li></ol><p>为什么需要三次？ 三次报文握手的过程是为了双方确定对方发送和接受能力的过程，通过第三次握手，服务端可以确认客户端的接受能力。 如果只有两次报文握手，可能会出现这种情况： 客户端发送一个报文后，由于开始网络阻塞，报文没有成功到达服务端，于是客户端重传报文，第二次重传的报文成功到达服务端，服务端成功响应后断开连接。这是服务端接受到了第一次请求的报文(网络好了)，误认为是新的连接，向客户端发送确认报文，但是客户端忽略了服务端发送的确认报文，不发送任何数据，这是服务端一直在等待重传，这无疑极大的浪费了资源。</p><p>什么是半连接队列？ 当服务端收到客户端请求并发送确认报文后，进入SYN_RCVD状态，此时双方还没有完全建立连接，服务器将这个状态下的请求连接放入一个队列，这个队列就是半连接队列 全连接队列是三次报文握手后，双方建立好连接请求的连接放入全连接队列。</p>',122),d=[a];function c(p,r){return l(),i("div",null,d)}const T=e(t,[["render",c],["__file","HTTP.html.vue"]]);export{T as default};
